import firebase from 'firebase';

import { convertDateFormatToHHMM } from '~/utils/functions';
import * as firebaseActions from './actions';
import * as errorThunk from '@store/error/thunk';

const unsubscribeFirebaseListeners = [];

export function signInOrSignUpToFirebase() {//if there's no record try sign in, otherwise: sign up
    return async (dispatch, getState) => {

        const userEmail = getState()?.dashboard?.userData?.email;

        const addUserOnFirestore = async (user) => {
            try {
                const db = firebase.firestore();

                await db.collection('users')
                    .doc(user.uid)
                    .set({
                        mySqlUserId: userEmail,
                        uid: user.uid,//generated by firebase
                        isOnline: true,
                        createdAt: new Date()
                    });

                dispatch(firebaseActions.updateFirebaseUidOnRedux(user.uid));
            } catch (err) {
                dispatch(errorThunk.handleThunkError(err));
            };
        }

        firebase.auth().signInWithEmailAndPassword(userEmail, userEmail).then(user => {

            dispatch(firebaseActions.updateFirebaseUidOnRedux(user.user.uid));
            dispatch(getRealtimeMessagesFromFirebase());

            dispatch(firebaseActions.updateFirebaseUserOnRedux({ uid: user.user.uid }));

        }).catch(err => {

            if (err.code === 'auth/user-not-found') {

                firebase.auth().createUserWithEmailAndPassword(userEmail, userEmail).then(user => {

                    addUserOnFirestore({ uid: user.user.uid });

                    dispatch(firebaseActions.updateFirebaseUserOnRedux({ uid: user.user.uid }));

                }).catch(err => {
                    dispatch(errorThunk.handleThunkError(err));
                })
            }
            else {
                dispatch(errorThunk.handleThunkError(err));
            }
        })
    }
}

export function getRealtimeMessagesFromFirebase() {
    return (dispatch, getState) => {

        const { id: userId } = getState().dashboard.userData;

        const db = firebase.firestore();

        var realTimeFirebaseChat1 = [];
        var realTimeFirebaseChat2 = [];
        var realTimeFirebaseChatFinal = [];
        //I'm using this ^ two helper arrays cause firestore doesn't accept OR operator

        unsubscribeFirebaseListeners.push(
            db.collection('chat')
                .where('userId_1', '==', userId)
                .orderBy('createdAt', 'asc')
                .onSnapshot(async (querySnapshot) => {

                    realTimeFirebaseChat1 = [];

                    querySnapshot.forEach(doc => {
                        realTimeFirebaseChat1.push(doc.data());
                    });

                    unsubscribeFirebaseListeners.push(db.collection('chat')
                        .where('userId_2', '==', userId)
                        .orderBy('createdAt', 'asc')
                        .onSnapshot(async (querySnapshot) => {

                            realTimeFirebaseChat2 = [];

                            querySnapshot.forEach(doc => {
                                realTimeFirebaseChat2.push(doc.data());
                            });

                            realTimeFirebaseChatFinal = [];

                            realTimeFirebaseChatFinal = realTimeFirebaseChat1.concat(realTimeFirebaseChat2)
                                .sort((a, b) => b.createdAt - a.createdAt)//order all messages desc by date

                            realTimeFirebaseChatFinal = realTimeFirebaseChatFinal.map(item => ({
                                ...item,
                                hourMinute: convertDateFormatToHHMM(item.createdAt.toDate())
                            }));

                            realTimeFirebaseChatFinal = realTimeFirebaseChatFinal.map((item, index) =>
                                ({ ...item, id: (item.createdAt.nanoseconds + item.createdAt.seconds + index).toString() })
                            );

                            dispatch(firebaseActions.updateRealTimeFirebaseChat(realTimeFirebaseChatFinal));
                        })
                    );
                })
        );
    }
}

export function sendMessageToFirebase(message, matchedProfileId) {
    return async (dispatch, getState) => {

        const db = firebase.firestore();

        await db.collection('chat')
            .add({
                userId_1: getState().dashboard.userData.id,
                userId_2: matchedProfileId,
                createdAt: new Date(),
                isView: false,
                message
            })
            .catch(err => {
                dispatch(errorThunk.handleThunkError(err));
            });
    }
}

export function removeAllConversationsFromThisMatch(matchedProfileId) {
    return async (dispatch, getState) => {

        const loggedUserId = getState().dashboard.userData.id;

        try {
            const db = firebase.firestore();

            const conversation1 = db.collection('chat')
                .where('userId_1', '==', loggedUserId)
                .where('userId_2', '==', matchedProfileId);

            conversation1.get().then(function (querySnapshot) {
                querySnapshot.forEach(function (doc) {
                    doc.ref.delete();
                });
            });

            const conversation2 = db.collection('chat')
                .where('userId_1', '==', matchedProfileId)
                .where('userId_2', '==', loggedUserId);

            conversation2.get().then(function (querySnapshot) {
                querySnapshot.forEach(function (doc) {
                    doc.ref.delete();
                });
            });

        } catch (err) {
            dispatch(errorThunk.handleThunkError(err));
        }
    }
}

